目标与约束（你确认的方案 B）
分布式伤害：施法者在本地把 self.* 相关变量替换/编译后，形成 DamageRequest（或编译产物），交给“伤害分发服务”。
跨帧区域：存在移动/持续的伤害区域（冲撞、贴地、螺旋、往返等），必须 每帧 tick。
命中策略：允许多次命中，且同目标每 N 帧可再次命中（N 来自请求参数）。
过滤策略：采用 B（SpaceManager 只做几何查询，阵营/队伍/规则过滤在 dispatcher/area 内做）。
运作流程（端到端）
1) 施法者侧（行为树动作/技能逻辑）
在某个时间点执行 singleAttack/rangeAttack/enemyAttack/moveAttack 之类动作。
动作负责：
解析伤害表达式（至少提取 self.* 依赖）
从 StatContainer/运行时上下文取值，完成 self 侧替换（必要时用 SchemaPathResolver 做依赖提取与校验）
生成 DamageAreaRequest：
包含：已编译/替换后的公式、区域几何参数、轨迹参数、命中节流参数 N、生命周期参数、过滤参数（enemy/ally/any/self）
然后调用：engine.world.areaManager.damageDispatcher.submit(request)（或同等入口）。
2) 世界侧（World.tick(frame)）
World.tick 已经会调用 areaManager.tick(frame)
在 AreaManager.tick(frame) 内：
调用 damageDispatcher.tick(frame)
3) 伤害分发服务（每帧）
DamageDispatcher.tick(frame)：
遍历所有存活的 DamageAreaInstance
对每个 instance：
更新轨迹/形状（得到当前 frame 的 transform + shape）
spaceManager.queryXxx(shape) 得到候选 members
进行过滤（enemy/ally/any/self）
执行命中节流（每目标每 N 帧一次，内部维护 lastHitFrameByTargetId)
为命中的目标构造/派发 DamageRequest（注入动态变量：distance、targetCount、hitIndex、elapsedFrames…）
结束条件：到达 endFrame / 达到最大命中次数 / 被外部取消
4) 受击者侧（状态机/结算）
目标 member 收到 DamageRequest 事件（你们已有 记录伤害请求 等入口）
受击者进入“伤害计算管线”，执行命中/减伤/状态等逻辑，并把结果反馈给施法者（已有“反馈命中结果给施法者”等动作）。
职责划分（清晰边界）
SpaceManager
只做几何查询：给定 shape/参数返回候选对象
不关心 camp/team、可选中、无敌等业务规则
AreaManager
世界里各种“跨帧实例”的生命周期管理入口（目前是占位）
调度子系统：damageDispatcher.tick(frame)（以及未来其他 area 类型，比如陷阱、投射物、地形效果）
DamageDispatcher（建议新增）
维护 DamageAreaInstance[]
负责：
submit/cancel
tick 调度
清理过期实例
DamageAreaInstance
单个区域实体的运行时状态（跨帧）
负责：
轨迹更新（位置/朝向/尺度）
命中去重/节流
构造对目标的派发请求
施法者动作（GlobalActions.*Attack）
只负责构造请求，不做空间查询、不做跨帧循环
负责 self 侧替换/编译表达式（可用 SchemaPathResolver）
接口设计（最小可实现版本）
1) DamageAreaRequest（施法者提交）
identity
sourceId: string（施法者 memberId）
skillId?: string / effectId?: string（可选，方便回放/调试）
lifetime
startFrame: number
durationFrames: number（或 endFrame）
targeting/filter（方案 B：在 dispatcher 过滤）
targeting: "enemy" | "ally" | "any" | "self"
includeSelf?: boolean（可选）
hit policy
hitIntervalFrames: number（你确认 N 从参数来）
maxHitsPerTarget?: number（可选）
maxTotalHits?: number（可选）
shape（空间查询形状）
shape: { kind: "circle"; radius: number } | { kind: "capsule"; halfWidth: number; length: number } | ...
trajectory（跨帧运动）
trajectory: { kind: "static"; position: Vec3 } | { kind: "linear"; start: Vec3; dir: Vec3; speed: number } | { kind: "spiral"; ... } | { kind: "custom"; params: ... }
damage payload（分布式的核心）
compiledDamageExpr: string | CompiledExpression（建议最终是编译产物，而不是原始字符串）
expApplicationType / expResolutionType（你现在的惯性字段）
attackCount: number（多段/多次伤害语义）
damageCount: number（如果需要做均分/分段）
selfBindings: Record<string, number | string | boolean>（self 已替换/绑定的变量表，视你表达式系统而定）
2) DamageDispatcher
submit(request: DamageAreaRequest): string → 返回 areaId
cancel(areaId: string): void
tick(frame: number): void
3) DamageAreaInstance
tick(frame: number, deps: { spaceManager; memberManager; emitDamage(targetId, request) }): void
内部状态：
lastHitFrameByTargetId: Map<string, number>
totalHitCount
createdFrame/endFrame
4) 目标接收事件（事件形态先不定实现）
emitDamage(targetId, payload) → 进入目标 state machine：
type: "受到攻击" / data: { damageRequest }（你们已有类似结构）
为什么“陷阱/区域”不建议用行为树描述
行为树适合“角色决策流程”，不擅长“跨帧空间实例”的批量 tick、命中去重、集合过滤。
如果每个陷阱/区域都跑 BT，会导致：
需要在 BT 内实现大量状态缓存（lastHitFrame、hitCount…）
空间查询频率高且难以统一优化（批处理、索引、缓存）
推荐：BT 只负责创建/取消区域实例；区域运行交给 dispatcher/instances。
下一步（你审核后再实现）
如果你认可这个边界与接口，我建议下一轮把 DamageAreaRequest 的字段精简到刚好覆盖你现有四类 attack（single/range/enemy/move），并确定：
moveAttack 用什么 shape（capsule/box）和 trajectory（linear）
enemyAttack 是以施法者当前位置为中心的 circle，还是围绕目标？
attackCount/damageCount 与命中 tick 的关系（“每次命中都造成一次伤害” vs “attackCount 表示同一 tick 内多段”）
你回复“OK + 这三类的语义确认”，我再把接口收敛成一版最终草案（字段更少、更具体）。