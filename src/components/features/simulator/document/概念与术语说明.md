## 概念与术语说明（Simulator Core）

### 目标
- **统一语义**：同一个词在文档/代码/讨论中指向同一个概念。
- **明确边界**：哪些模块负责“产出动作”，哪些模块负责“执行动作”，哪些模块只负责“调度”。
- **可演进**：在不推倒现有实现的前提下，为后续“统一动作落地（commit）”留出空间。

### 术语对照（推荐用词）
为避免 “action” 一词在不同体系里复用导致歧义，建议在讨论与新代码中优先使用以下术语：

- **Intent（意图/命令）**：执行单元产出的“副作用请求”（移动、加 buff、发事件、运行结算等），由 `Resolver` 统一落地。
- **Pipeline（管线，等价 ActionGroup）**：结算流程的编排（阶段列表）。
- **Stage（阶段，现有 actionPool 内的 action）**：管线中的单个计算/结算步骤（schema + impl）。
- **FsmAction（状态机动作）**：XState 内部的 transition/entry/exit 副作用描述（建议只产出 Intent，不直接改世界）。

---

## 1. 执行单元 vs 调度单元

### 执行单元（Executor）
满足以下特征的模块/对象可视为执行单元：
- **可读取场景/成员上下文**（I/O：成员属性、buff、目标、位置、区域信息等）
- **能在 tick 中推进自身逻辑**
- **产出可执行的意图（Intent）**（描述“要发生什么副作用”）

当前设计中：
- **Member** 是核心执行单元（见 `架构设计说明概要.md`）。
- **Area（区域实例）** 可以视为执行单元：它对成员产生影响并需要随帧推进。
- **World/Scene** 通常是执行单元容器（承载空间/区域/成员集合），是否“作为执行者”取决于它是否也产出动作。

### 调度单元（Scheduler）
调度单元只负责“什么时候、按什么顺序”推进，不负责具体战斗规则：
- **FrameLoop**：推进帧（实时/快速模拟）。
- **EventQueue**：跨帧事件调度（主要用于向状态机发送消息）。
- **GameEngine**：串联帧循环、事件、成员更新、日志与任务。

---

## 2. action 的三重含义（必须区分）

在本项目讨论中，至少存在三种常见的 “action”：

### 2.1 Intent（意图/命令）：执行单元输出的副作用请求
来源于我们达成的共识：**行为树只输出意图（Intent），最终由 Resolver 处理并落地副作用**。

Intent 的特点：
- 是**数据描述**（可记录/回放/调试），不等价于立即执行的函数调用。
- 由 **SkillBT / BuffBT / AreaBT / 状态机逻辑** 产出。
- 由 `Resolver` 在 commit 阶段落地（或按项目选择的执行模式落地）。

示例（概念）：`Move` / `DealDamage` / `AddBuff` / `SendFsmEvent` / `RunPipeline` 等。

### 2.2 Stage（阶段）：结算/计算步骤（现有 actionPool 的“action”）
在 `runtime/Action/ActionManager.ts` / `runtime/Action/type.ts` 中：
- `actionPool[actionName] = [inputSchema, outputSchema, impl]`

Stage 的特点：
- 目标是串联输入输出，形成可执行的**结算流程**（Pipeline）。
- 通常应尽量保持“结算/计算”语义，避免承担过多跨系统副作用（否则会与 Intent/Resolver 的边界混淆）。

### 2.3 FsmAction（状态机动作）：XState 内部副作用描述
XState 的 action（entry/exit/transition actions）属于“状态机建模语言”的一部分：
- 用来描述状态转换附带的副作用。
- 建议约束：**状态机 action 主要负责产出 Intent（或发状态机内部事件），不要直接改世界**，以保证副作用入口一致。

---

## 3. ActionGroup 与 Pipeline 的关系

### 3.1 ActionGroup（动作组）是什么
在 `ActionManager` 中：
- `actionGroupDef[actionGroupName] = [stageName1, stageName2, ...]`

ActionGroup 本质是：
- **阶段的编排定义**（顺序表）
- 不包含实现，只描述“这一组要跑哪些阶段、顺序如何”

### 3.2 Pipeline（管线）是什么
“Pipeline”只是更通用的叫法，用来表达：
- 一条由多个 Stage 串起来的计算/结算流程

因此：
- **ActionGroup ≈ Pipeline（同义）**

为了避免和“成员动作(Action)”混淆：
- 文档里可以继续用 **动作组(ActionGroup)**
- 讨论“计算流程”时可说 **管线(Pipeline)**
- 讨论“执行者产出的副作用请求”时说 **Intent**

---

## 4. 当前代码结构对应关系

### 4.1 管线执行（Stage/Pipeline 层）
- **Stage 定义**：`src/components/features/simulator/core/Member/runtime/Action/type.ts`
  - `ActionPool`：stageName -> `[inputSchema, outputSchema, impl]`
- **Pipeline/ActionGroup 执行器**：`src/components/features/simulator/core/Member/runtime/Action/ActionManager.ts`
  - `run(actionGroupName, ctx, params?)` 执行动作组
  - `compiledChains` 缓存编译后的执行链
  - `dynamicActions` 支持在静态阶段之后插入动态阶段（多用于 buff/技能特殊逻辑）

### 4.2 成员执行（Executor 层）
- `src/components/features/simulator/core/Member/Member.ts`
  - `actor`：XState 状态机（接受“更新”等事件）
  - `buffManager`：buff 生命周期与效果落地（当前为“属性修改 + 动态插管线 + frame.update 特例”）
  - `actionManager`：管线执行器（Stage/Pipeline 层）

### 4.3 buff 当前实现（需要注意的点）
- `src/components/features/simulator/core/Member/runtime/Buff/BuffManager.ts`
  - buff effect 目前支持：
    - `stat`：通过 `StatContainer.addModifier/removeModifier` 落地
    - `actionGroup`：通过 `ActionManager.insertDynamicStage` 注入动态逻辑
  - `frame.update` 目前是硬编码特例：每帧执行一次表达式/函数

这套实现的优点：快速、灵活；
缺点：副作用入口分散（buff 既可能改属性又可能插管线又可能每帧执行逻辑）。

---

## 5. 推荐的“统一动作落地（commit）”方向（演进，不要求一次做完）

### 5.1 为什么需要 commit
当技能逻辑、buff 逻辑、区域逻辑都逐步变成“每帧 tick 的行为树 + 状态机”时：
- 如果所有模块都能直接改世界，会出现 **顺序依赖、隐式耦合、难复盘/难调试**。
- 需要把“决策”与“执行”拆开：
  - **决策**：产出 Intent（我要发生什么副作用）
  - **执行**：Resolver 统一解释 Intent 并落地副作用（怎么做）

### 5.2 Intent 模型（BT/SM/Area 的统一输出）
Intent 描述的是“要发生什么”，典型包括：
- `SendFsmEvent`：向状态机发送事件
- `Move`：移动
- `DealDamage`：造成伤害
- `AddBuff/RemoveBuff`：增减 buff
- `RunPipeline`：触发某条结算管线（调用 `ActionManager.run`）
- `InsertPipelineStage/RemovePipelineStagesBySource`：动态改写某条管线

### 5.3 Resolver.commit（Intent 解释器）
- **输入**：本帧收集到的 Intent 列表（来源：SkillBT/BuffBT/AreaBT/状态机）
- **处理**：执行（必要时可做幂等/合并；是否排序取决于项目选择）
- **输出**：执行报告（用于 UI 与调试）

关键原则：
- BT/SM/Area 的 tick 阶段只“产出 Intent”，不直接改世界。
- 所有副作用集中在 commit，顺序稳定，便于录制/回放与调试。

### 5.4 立即执行 vs commit：两种模式都允许（推荐在团队内明确选择）
在本项目里，“每帧 tick 的顺序固定”（例如先 SkillBT 再 BuffBT，且 BuffBT 内遍历顺序稳定）时，**叶子节点立即执行动作**同样具备确定性。

因此我们允许两种模式：

1. **立即执行模式（KISS，推荐作为当前默认）**
   - BT 叶子节点直接调用执行接口（例如移动、发送状态机事件、插入动态阶段等）。
   - “顺序就是规则”：同一帧内谁先执行谁先生效。
   - 注意：为了避免“遍历期间修改集合”的隐性 bug，仍建议对关键集合使用“延迟变更”策略：
     - 例如 `BuffManager.tick()` 当前就采用“先收集过期列表，再批量移除”的方式，避免在遍历 `Map` 时删除元素。
     - 约定：**遍历 Buff/Area/动态阶段列表期间，不直接增删该集合；改为记录到 pending 列表，在本段遍历结束后统一处理。**

2. **commit 模式（可演进能力，用于需要统一裁决/回放/可观测性时）**
   - BT/SM/Area 的 tick 只“产出动作（数据）”，不直接落地副作用。
   - 帧末由 `Resolver.commit()` 统一落地，并可产出完整“本帧动作清单”用于调试与回放。
   - 说明：commit 并不必然意味着二次排序；也可以按产出顺序执行，仅对少数动作类型做幂等/合并。

关于“同帧动作是否冲突”的约定（避免误解）：
- 帧可以被视为“上一帧到这一帧期间动作的总和”，因此同帧内可以同时发生多个位移/状态变化；是否互斥取决于规则设计，而不是由架构强制限制“一帧只能做一件事”。
---

## 6. World/Space/Area 的分层建议

### 6.1 为什么 SpaceManager 与 AreaManager 分离
- **SpaceManager（空间系统）**：提供通用的空间索引/查询能力（规则无关），供选目标、区域覆盖判定、碰撞等复用。
- **AreaManager（区域系统）**：维护区域实例生命周期与规则（规则相关），基于空间查询产出动作。

把两者分离能避免把“空间算法”与“规则逻辑”搅在一起，降低复杂度并提升复用性。

### 6.2 World 是否必须 actor 化
不必须。
- World 可以是普通对象：持有 manager 集合并在每帧调用它们。
- 如果未来需要并发/可视化状态机，也可以再 actor 化，但不是前置条件。

---

## 7. 数据作用域（避免跨技能共享冲突）

当你需要跨技能共享状态（灵光/弧光、充能等），请区分：
- **管线内数据流**：`ActionManager` 内的 `prevOutput/actionOutputs` 只适合“管线阶段之间传递”。
- **跨技能共享**：建议放在更接近 member 的持久层：
  - `Buff variables`（适合“状态效果/层数/窗口期”等）
  - `Member memory/blackboard`（适合“系统级共享、缓存、上次技能/目标”等）

原则：
- 不要把“跨技能共享”寄托在 `prevOutput` 的合并上。

---

## 8. 命名与沟通约定（强制建议）

为了避免讨论时混淆，建议团队约定：
- **Intent（意图）**：执行单元产出的副作用请求（BT/SM/Area 的统一输出）
- **Stage（阶段）**：指 `actionPool` 中的结算/计算阶段
- **Pipeline（管线）/ActionGroup（动作组）**：指阶段编排（同义）
- **FsmAction（状态机动作）**：XState 内部 action

如果必须在代码里继续使用 `ActionManager/actionPool` 这套命名：
- 请在文档/注释中明确它们代表的是 **Stage/Pipeline**，避免与 **Intent** 混淆。
