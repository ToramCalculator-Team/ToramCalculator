为了有尽量高的技能可能性，我设计了目前的技能运行架构：
1.引擎开放基本的数据I/O、事件管理、表达式计算等能力，用函数包裹他们并在编辑器中以积木形式展示，此类与引擎耦合的简单方法目前我称之为“动作”。
2.技能和buff都用行为树表述，行为树中除了逻辑节点（分支、循环、顺序、延迟等）之外，实际执行行为的都是动作节点。
3.由逻辑节点分割开的动作组目前称之为“阶段”，即内部都是顺序执行的动作，设计阶段层的主要目的是复用动作组和定位动作方便插入流程修改逻辑。
4.通过编辑器设计阶段和行为树来达到描述技能流程的目的，为了方便全局或者整个角色的阶段管理，阶段设计为分层分布，类似css样式覆盖，高层同名阶段将被底层阶段覆盖，计算时将优先选择底层阶段。
5.技能持有自己的上下文，执行一个技能时，创建该上下文，之后所有动作的输入都从上下文获取，输出都记录到上下文里。
6.为了提高技能灵活度（比如执行某个技能后，角色的某些技能计算流程会发生变化），阶段内的每个动作后都允许插入“修饰器”。比如效果“此技能伤害根据角色HP比例获得魔法贯穿”，将会在当前角色的当前技能阶段管理器内做插入（伤害计算阶段的魔法贯穿计算动作后插入表达式为“m.pie += hp.current / hp.max”的修饰器）。之后执行伤害计算阶段时，在魔法贯穿计算后、怪物防御计算前，会将上下文内的角色魔法贯穿做修改。

type Action = Function

type Segment = {
    name: string;
    actions: Action[];
}

type Modifier = string; // 形式应该是赋值表达式比如，magic_cannon_charage += chantingFrames / 2

global:{
    segments: Segment[]
    members: {
        segments: Segment[]
        skills: {
            segments: Segment[]
        }[]
    }[]
}

插入Modifier时需要定位到具体的Action，比如global.segments.where((a) => a.name === "XX")、global.members[0].skills[1].segments.where((a) => a.name === "XX")

我们设计里的技能效果结构包含3个部分，1是skillTree、2是buffTree、3是自定义阶段，但从魔法炮需要其他技能修改它的充能这点来看，我们需要向其它技能的技能发动阶段里插入一个“增幅魔法炮充能”的能力，此内容应该被定义在魔法炮技能逻辑里以便后续维护只用改它本身，由阶段管理器插入到对应的技能里。也就是说技能效果现在还需要第4个部分用来记录自定义的动作，“向其他动作后插入动作”这个行为本身应该是行为树叶子节点。

但是我们的伤害计算系统是分布式的，A角色构造伤害事件，发送给空间管理器，空间管理器计算接受伤害的目标并更新伤害事件中上海表达式里和目标数或距离有关的变量后发送伤害事件给对应目标。

成员执行技能后，根据行为树逻辑，在一定时间后会构建伤害事件，技能上下文不一定持有伤害计算需要的攻击力值和魔法贯穿等内容，而根据角色HP比例获得的额外贯穿计算逻辑位于魔法贯穿计算动作内。我们不可能把整个阶段管理器放进快照，转发给空间管理器，而应该只发送和表达式相关的数值作为负载。也就是说在构造伤害事件时，需要解析伤害表达式里和自己相关的内容，然后调用对应的数值获取动作得到数值。以“魔法贯穿计算动作”为例，这个逻辑目前处在StatContainer中，不受阶段管理器管理，我认为我们需要创建一个属性获取阶段，里面只有一个动作“属性获取”，伤害事件构造时，替换表达式中变量就用这个阶段（其中可能包含多个修饰器），这样就可以实现当前技能的魔法贯穿计算和其它技能计算不一样的效果？而且由于贯穿修饰器只存在于当前技能的阶段管理器中，其它技能也不会进行无效的计算而浪费性能。

积木中添加“外部影响”积木，描述：当XXX技能的XXX动作组的XXX动作执行完时，做XXXX

其实我不太想在代码里定义任何动作组，@CommonActions.ts (211-219) 这样的内容对于用户和编辑器来说是黑盒子。直接将默认动作组JSON化，在编辑器里以积木团的形式展示出来，这样既可以提供缺省值，也便于理解，并且可以由用户自己重新编排。所以这些模块里面要求传入动作组其实是不必要的，他们应该在运行时从技能数据JSON里读取再填入。