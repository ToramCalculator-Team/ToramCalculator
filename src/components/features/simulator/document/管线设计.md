为了有尽量高的技能可能性，我设计了目前的技能运行架构：
1.引擎开放基本的数据I/O、事件管理、表达式计算等能力，用函数包裹他们并在编辑器中以积木形式展示，此类与引擎耦合的简单方法目前我称之为“动作”。
2.技能和buff都用行为树表述，行为树中除了逻辑节点（分支、循环、顺序、延迟等）之外，实际执行行为的都是动作节点。
3.由逻辑节点分割开的动作组目前称之为“阶段”，即内部都是顺序执行的动作，设计阶段层的主要目的是复用动作组和定位动作方便插入流程修改逻辑。
4.通过编辑器设计阶段和行为树来达到描述技能流程的目的，为了方便全局或者整个角色的阶段管理，阶段设计为分层分布，类似css样式覆盖，高层同名阶段将被底层阶段覆盖，计算时将优先选择底层阶段。
5.技能持有自己的上下文，执行一个技能时，创建该上下文，之后所有动作的输入都从上下文获取，输出都记录到上下文里。
6.为了提高技能灵活度（比如执行某个技能后，角色的某些技能计算流程会发生变化），阶段内的每个动作后都允许插入“修饰器”。比如效果“此技能伤害根据角色HP比例获得魔法贯穿”，将会在当前角色的当前技能阶段管理器内做插入（伤害计算阶段的魔法贯穿计算动作后插入表达式为“m.pie += hp.current / hp.max”的修饰器）。之后执行伤害计算阶段时，在魔法贯穿计算后、怪物防御计算前，会将上下文内的角色魔法贯穿做修改。

type Action = Function

type Segment = {
    name: string;
    actions: Action[];
}

type Modifier = string; // 形式应该是赋值表达式比如，magic_cannon_charage += chantingFrames / 2

global:{
    segments: Segment[]
    members: {
        segments: Segment[]
        skills: {
            segments: Segment[]
        }[]
    }[]
}

插入Modifier时需要定位到具体的Action，比如global.segments.where((a) => a.name === "XX")、global.members[0].skills[1].segments.where((a) => a.name === "XX")

我们设计里的技能效果结构包含3个部分，1是skillTree、2是buffTree、3是自定义阶段，但从魔法炮需要其他技能修改它的充能这点来看，我们需要向其它技能的技能发动阶段里插入一个“增幅魔法炮充能”的能力，此内容应该被定义在魔法炮技能逻辑里以便后续维护只用改它本身，由阶段管理器插入到对应的技能里。也就是说技能效果现在还需要第4个部分用来记录自定义的动作，“向其他动作后插入动作”这个行为本身应该是行为树叶子节点。

但是我们的伤害计算系统是分布式的，A角色构造伤害事件，发送给空间管理器，空间管理器计算接受伤害的目标并更新伤害事件中上海表达式里和目标数或距离有关的变量后发送伤害事件给对应目标。

成员执行技能后，根据行为树逻辑，在一定时间后会构建伤害事件，技能上下文不一定持有伤害计算需要的攻击力值和魔法贯穿等内容，而根据角色HP比例获得的额外贯穿计算逻辑位于魔法贯穿计算动作内。我们不可能把整个阶段管理器放进快照，转发给空间管理器，而应该只发送和表达式相关的数值作为负载。也就是说在构造伤害事件时，需要解析伤害表达式里和自己相关的内容，然后调用对应的数值获取动作得到数值。以“魔法贯穿计算动作”为例，这个逻辑目前处在StatContainer中，不受阶段管理器管理，我认为我们需要创建一个属性获取阶段，里面只有一个动作“属性获取”，伤害事件构造时，替换表达式中变量就用这个阶段（其中可能包含多个修饰器），这样就可以实现当前技能的魔法贯穿计算和其它技能计算不一样的效果？而且由于贯穿修饰器只存在于当前技能的阶段管理器中，其它技能也不会进行无效的计算而浪费性能。

积木中添加“外部影响”积木，描述：当XXX技能的XXX动作组的XXX动作执行完时，做XXXX

其实我不太想在代码里定义任何动作组，@CommonActions.ts (211-219) 这样的内容对于用户和编辑器来说是黑盒子。直接将默认动作组JSON化，在编辑器里以积木团的形式展示出来，这样既可以提供缺省值，也便于理解，并且可以由用户自己重新编排。所以这些模块里面要求传入动作组其实是不必要的，他们应该在运行时从技能数据JSON里读取再填入。

-----------------------------------

行为树（Behavior3）在你项目里的运行模型
1) Tree / Node / Blackboard
Tree：每棵树每帧 tick() 一次，从 root 往下跑。
Node：每个节点 onTick(tree, status)，返回 success / failure / running。
Blackboard：树的“局部变量表”。
Check 节点会走 tree.blackboard.eval(expr)。
eval 的执行上下文来自 MemberBehaviorTreeRuntime.buildExecutionContext(values)，默认是：
...owner（状态机 context）
...values（blackboard 上的键值）
结论：表达式里能直接用的变量 = owner 字段 + blackboard 变量。如果两边都没有，就会 ReferenceError（例如 buffExists is not defined）。
动作（Pipeline / Stage）与“意图（Intent）”是怎么跑的
2) BehaviorTree 叶子节点现在做的是“产出 Intent”
比如：
RunPipeline：push { type: "runPipeline", pipeline: xxx, params }
ScheduleFSMEvent：push { type: "sendFsmEvent", event }
InsertDynamicStage：push { type: "insertPipelineStage", ... }
它们不直接执行，而是把“要做什么”写进 intentBuffer。
3) World / Resolver：统一落地副作用
World.tick() 里会收集并执行 Intent。
Resolver.commit(intents) 会按类型执行：
sendFsmEvent → member.actor.send(...)（触发状态机）
runPipeline → member.pipelineManager.run(pipeline, ctx, params)
其它类似
你现在的系统里，“副作用落地”统一在 Resolver，BT 负责“决策/产出意图”。
上下文（Context）到底是什么、数据在哪里
4) 状态机 context（owner）是跨帧/跨技能的主要数据载体
例如 PlayerStateContext 里有：
currentSkillStartupFrames / ...（技能阶段帧）
skillState / buffState / blackboard（你在 BTManger 里确保存在的共享对象）
pipelineManager / buffManager / statContainer 等
跨技能共享数据最自然的落点是：
Buff：放到 buff.variables / buffState.xxx（由 buff 管理生命周期）
技能链/技能按钮变体（灵光剑舞→弧光剑舞）：可以用
buff（最推荐，表达“状态/形态”）
或 skillState.xxx（更像“技能系统内部状态”）
5) PipelineManager 的关键：它默认是“ctx working copy”
PipelineManager.run() 内部会：
currentCtx = { ...ctx }（工作副本）
每个 stage 输出 Object.assign(currentCtx, stageOut)
最后返回 { ctx: currentCtx, actionOutputs }
如果调用方不把返回的 ctx 合并回状态机 context，那么 BT 表达式就读不到 stage 的输出变量。
（我之前已经在 Resolver.execRunPipeline 做了 Object.assign(ctx, newCtx) 这件事，理论上 buff.check 产出的 buffExists 应该会回写到 actor 的 context。）

---------------------------------------------

不建议在所有叶子节点都"立即执行副作用"，但强烈建议把"需要被同 tick 依赖的东西"同步化
关键是把"动作"拆成两类：
纯计算/查询类（应该同步执行）
例：skill.motion.calculate、skill.cost.calculate、buff.check（本质是查询/计算）
这些如果不在 BT tick 内立即得到结果，BT 就无法用自然的写法表达条件分支与参数传递。
副作用类（更适合 intent 统一落地）
例：sendFsmEvent、跨模块/跨成员的修改、动态插阶段、创建区域等
这些统一走 intent 的好处是：顺序可控、可回放、可裁决（尤其多人/多模块冲突时）。
也就是说：推荐"混合模型" —— BT 叶子节点对"计算/查询"直接执行并写回 owner/blackboard；对"副作用"仍产出 intent。
为什么我不赞成"所有动作都立即执行"
即使模块顺序固定，"立即执行副作用"仍容易带来两个工程风险：
重入/递归执行：BT tick 中触发状态机/再触发 BT，或触发别的系统回写，容易出现你现在已经见到的那种链式调用问题，只是更隐蔽。
调试/回放/裁决能力下降：你现在这个项目很强调逐帧分析和可视化，intent 作为"可追踪的副作用日志"价值很大。

---------------------------------------------

## Pipeline 执行模式分类（同步 vs Intent）

### 同步类 Pipeline（使用 RunPipelineSync 节点）

**特征**：纯计算/查询，无外部副作用，结果需要同 tick 内可见

**使用场景**：
- 行为树内后续节点需要依赖本次计算结果（如 `Check` 节点判断条件）
- 需要将计算结果作为参数传递给后续管线

**典型 Pipeline**：
- `skill.cost.calculate` - 技能消耗计算（输出 `skillHpCost`、`skillMpCost`）
- `skill.motion.calculate` - 技能动作时长计算（输出 `currentSkillStartupFrames`、`currentSkillChargingFrames`、`currentSkillChantingFrames`、`currentSkillActionFrames`）
- `buff.check` - Buff 存在性查询（输出 `buffExists`）
- `获取buff计数器值` - Buff 变量查询（输出 `chargeCounter` 等）
- `应用数值表达式` - 表达式计算（输出 `newValue`）

**实现方式**：
- 使用 `RunPipelineSync` 节点直接调用 `owner.pipelineManager.run(...)`
- 返回的 `ctx` 自动合并回 `owner`，同 tick 内表达式可见
- 或使用专用同步节点（如 `HasBuff`）更轻量

### 副作用类 Pipeline（使用 RunPipeline 节点）

**特征**：产生外部副作用，需要统一落地/裁决，或跨帧执行

**使用场景**：
- 需要统一记录 Intent 日志（用于逐帧分析/回放）
- 跨模块/跨成员的修改（需要 Resolver 裁决）
- 动态插入阶段、创建区域等需要延迟执行的逻辑

**典型 Pipeline**：
- `sendFsmEvent` - 状态机事件（通过 `ScheduleFSMEvent` 节点）
- `insertPipelineStage` - 动态插入阶段（通过 `InsertDynamicStage` 节点）
- `addBuff` / `removeBuff` - Buff 添加/移除（通过 Intent）
- `combat.damage.request` - 伤害结算请求（通过 Intent）
- `event.*.schedule` - 事件调度（通过 Intent）

**实现方式**：
- 使用 `RunPipeline` 节点产出 Intent
- 由 `Resolver.commit()` 统一执行
- 保持可追踪/可回放能力

### 分类规则总结

1. **判断标准**：如果后续 `Check` 节点需要读取本次计算结果 → 用同步模式
2. **默认策略**：不确定时优先用 Intent 模式（更安全），需要时再改为同步
3. **性能考虑**：频繁查询类操作（如 `HasBuff`）建议用专用同步节点，不走完整 Pipeline