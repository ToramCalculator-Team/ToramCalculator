# 跨技能数据共享约定

## 概述

在技能系统中，某些数据需要在**不同技能之间共享**（例如：灵光剑舞的层数需要被弧光剑舞读取）。本约定定义了这些共享数据的存储位置与访问方式。

## 设计原则

1. **Buff 优先**：形态/层数/持续时间等状态数据优先存储在 `Buff.variables` 中
2. **buffState 映射**：运行时维护 `buffState.<buffId>.<var>` 映射，便于表达式访问
3. **生命周期管理**：Buff 的生命周期自动管理数据的创建与清理

## 数据存储位置

### 1. Buff.variables（推荐）

**适用场景**：
- 技能形态/状态（如：灵光剑舞→弧光剑舞的形态切换）
- 层数/计数器（如：魔法炮充能层数、灵光剑舞层数）
- 持续时间相关的状态标记

**数据结构**：
```typescript
interface BuffInstance {
  id: string;
  name: string;
  variables?: Record<string, number | boolean>;
  // ...
}
```

**访问方式**：
- **同步查询**：`buffManager.getVariable(buffId, varName, defaultValue)`
- **同步设置**：`buffManager.setVariable(buffId, varName, value)`
- **表达式访问**：`buffState.<buffId>.<varName>`（由运行时维护映射）

### 2. skillState（备选）

**适用场景**：
- 技能系统内部的临时状态（不跨技能）
- 技能链的中间数据（短期共享）

**数据结构**：
```typescript
// 在 MemberStateContext 中
skillState?: Record<string, unknown>;
```

**访问方式**：
- **表达式访问**：`skillState.<key>`
- **直接写入**：`owner.skillState[key] = value`

## 运行时映射（buffState）

`BTManger` 在初始化时会确保 `owner.buffState` 存在：

```typescript
if (!(owner as any).buffState) (owner as any).buffState = {};
```

**映射规则**：
- `buffState.<buffId>.<varName>` 自动映射到 `buffManager.getVariable(buffId, varName)`
- 在表达式执行时，`buffState` 会被合并到执行上下文

**注意**：当前实现中，`buffState` 是**只读视图**，修改需要通过 `buffManager.setVariable()` 或 Intent。

## 行为树节点使用

### 查询 Buff 变量

**方式 1：使用 `HasBuff` 节点（推荐）**
```json
{
  "name": "HasBuff",
  "args": {
    "buffId": "magic_cannon_charge",
    "outputVar": "buffExists"
  }
}
```

**方式 2：使用 `RunPipelineSync` 节点**
```json
{
  "name": "RunPipelineSync",
  "args": {
    "actionGroupName": "获取buff计数器值",
    "params": {
      "buffId": "magic_cannon_charge"
    }
  }
}
// 结果写入 owner.chargeCounter
```

### 修改 Buff 变量

**方式 1：通过 Intent（推荐，用于副作用）**
```json
{
  "name": "RunPipeline",
  "args": {
    "actionGroupName": "应用数值表达式",
    "params": {
      "targetPath": "buffState.magic_cannon_charge.chargeCounter",
      "expression": "x + chantingFrames",
      "vars": { "chantingFrames": "chantingFrames" }
    }
  }
}
```

**方式 2：直接调用（仅限同步节点内）**
- 在 `RunPipelineSync` 的 stage 实现中直接调用 `buffManager.setVariable()`

## 示例：灵光剑舞 → 弧光剑舞

### 数据存储

灵光剑舞的层数存储在 Buff 中：

```typescript
{
  id: "sword_dance_aura",
  name: "剑舞灵光",
  variables: {
    stacks: 0,  // 层数
    startFrame: 0
  }
}
```

### 行为树访问

**灵光剑舞技能**：
- 添加 Buff：`RunPipeline("buff.add", { buffId: "sword_dance_aura", variables: { stacks: 0 } })`
- 每 2 秒叠加层数：通过 buff 行为树更新 `buffState.sword_dance_aura.stacks`

**弧光剑舞技能**：
- 读取层数：`RunPipelineSync("获取buff计数器值", { buffId: "sword_dance_aura" })`
- 或表达式：`buffState.sword_dance_aura.stacks`
- 持续时间计算：`duration = buffState.sword_dance_aura.stacks * 3`

## 注意事项

1. **Buff 生命周期**：Buff 被移除时，`buffState.<buffId>` 也会失效（表达式访问会返回 undefined）
2. **并发安全**：`buffManager.setVariable()` 是同步方法，在同一帧内多次调用是安全的
3. **表达式访问**：`buffState` 映射在表达式执行时动态计算，不保证实时性（建议在需要时用 `RunPipelineSync` 显式读取）
4. **跨成员数据**：本约定仅适用于**同一成员内部**的跨技能共享，跨成员数据需要通过其他机制（如事件/消息）

## 未来扩展

如需通过 Intent 统一修改变量（保持可追踪性），可考虑添加：

```typescript
interface ModifyBuffVarIntent extends IntentBase {
  type: "modifyBuffVar";
  targetId: string;
  buffId: string;
  varName: string;
  value: number | boolean;
  // 或使用表达式
  expression?: string;
}
```

当前阶段，直接调用 `buffManager.setVariable()` 或通过 `应用数值表达式` pipeline 已足够。

